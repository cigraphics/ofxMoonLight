/**
 *
 * MACHINE GENERATED FILE. DO NOT EDIT.
 *
 * Bindings for class ofDirectory
 *
 * This file has been generated by dub 2.1.~.
 */
#include "dub/dub.h"
#include "api/openFrameworks/utils/ofFileUtils.h"


/** ~ofDirectory()
 * 
 */
static int ofDirectory__ofDirectory(lua_State *L) {
  try {
    DubUserdata *userdata = ((DubUserdata*)dub_checksdata_d(L, 1, "ofDirectory"));
    if (userdata->gc) {
      ofDirectory *self = (ofDirectory *)userdata->ptr;
      delete self;
    }
    userdata->gc = false;
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "__gc: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "__gc: Unknown exception");
  }
  return dub_error(L);
}

/** ofDirectory::ofDirectory()
 * api/openFrameworks/utils/ofFileUtils.h:199
 */
static int ofDirectory_ofDirectory(lua_State *L) {
  try {
    int top__ = lua_gettop(L);
    if (top__ >= 1) {
      string *path = *((string **)dub_checksdata(L, 1, "string"));
      ofDirectory *retval__ = new ofDirectory(*path);
      dub_pushudata(L, retval__, "ofDirectory", true);
      return 1;
    } else {
      ofDirectory *retval__ = new ofDirectory();
      dub_pushudata(L, retval__, "ofDirectory", true);
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "new: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "new: Unknown exception");
  }
  return dub_error(L);
}

/** void ofDirectory::open(string path)
 * api/openFrameworks/utils/ofFileUtils.h:202
 */
static int ofDirectory_open(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    string *path = *((string **)dub_checksdata(L, 2, "string"));
    self->open(*path);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "open: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "open: Unknown exception");
  }
  return dub_error(L);
}

/** void ofDirectory::close()
 * api/openFrameworks/utils/ofFileUtils.h:203
 */
static int ofDirectory_close(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    self->close();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "close: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "close: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofDirectory::create(bool recursive=false)
 * api/openFrameworks/utils/ofFileUtils.h:204
 */
static int ofDirectory_create(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    int top__ = lua_gettop(L);
    if (top__ >= 2) {
      bool recursive = dub_checkboolean(L, 2);
      lua_pushboolean(L, self->create(recursive));
      return 1;
    } else {
      lua_pushboolean(L, self->create());
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "create: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "create: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofDirectory::exists() const
 * api/openFrameworks/utils/ofFileUtils.h:206
 */
static int ofDirectory_exists(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    lua_pushboolean(L, self->exists());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "exists: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "exists: Unknown exception");
  }
  return dub_error(L);
}

/** string ofDirectory::path() const
 * api/openFrameworks/utils/ofFileUtils.h:207
 */
static int ofDirectory_path(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    dub_pushudata(L, new string(self->path()), "string", true);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "path: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "path: Unknown exception");
  }
  return dub_error(L);
}

/** string ofDirectory::getAbsolutePath() const
 * api/openFrameworks/utils/ofFileUtils.h:208
 */
static int ofDirectory_getAbsolutePath(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    dub_pushudata(L, new string(self->getAbsolutePath()), "string", true);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getAbsolutePath: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getAbsolutePath: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofDirectory::isDirectory() const
 * api/openFrameworks/utils/ofFileUtils.h:214
 */
static int ofDirectory_isDirectory(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    lua_pushboolean(L, self->isDirectory());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "isDirectory: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "isDirectory: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofDirectory::isHidden() const
 * api/openFrameworks/utils/ofFileUtils.h:215
 */
static int ofDirectory_isHidden(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    lua_pushboolean(L, self->isHidden());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "isHidden: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "isHidden: Unknown exception");
  }
  return dub_error(L);
}

/** void ofDirectory::setWriteable(bool writeable)
 * api/openFrameworks/utils/ofFileUtils.h:217
 */
static int ofDirectory_setWriteable(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    bool writeable = dub_checkboolean(L, 2);
    self->setWriteable(writeable);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "setWriteable: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "setWriteable: Unknown exception");
  }
  return dub_error(L);
}

/** void ofDirectory::setReadOnly(bool readable)
 * api/openFrameworks/utils/ofFileUtils.h:218
 */
static int ofDirectory_setReadOnly(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    bool readable = dub_checkboolean(L, 2);
    self->setReadOnly(readable);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "setReadOnly: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "setReadOnly: Unknown exception");
  }
  return dub_error(L);
}

/** void ofDirectory::setExecutable(bool executable)
 * api/openFrameworks/utils/ofFileUtils.h:219
 */
static int ofDirectory_setExecutable(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    bool executable = dub_checkboolean(L, 2);
    self->setExecutable(executable);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "setExecutable: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "setExecutable: Unknown exception");
  }
  return dub_error(L);
}

/** void ofDirectory::setShowHidden(bool showHidden)
 * api/openFrameworks/utils/ofFileUtils.h:220
 */
static int ofDirectory_setShowHidden(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    bool showHidden = dub_checkboolean(L, 2);
    self->setShowHidden(showHidden);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "setShowHidden: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "setShowHidden: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofDirectory::copyTo(string path, bool bRelativeToData=true, bool overwrite=false)
 * api/openFrameworks/utils/ofFileUtils.h:222
 */
static int ofDirectory_copyTo(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    int top__ = lua_gettop(L);
    if (top__ >= 4) {
      string *path = *((string **)dub_checksdata(L, 2, "string"));
      bool bRelativeToData = dub_checkboolean(L, 3);
      bool overwrite = dub_checkboolean(L, 4);
      lua_pushboolean(L, self->copyTo(*path, bRelativeToData, overwrite));
      return 1;
    } else if (top__ >= 3) {
      string *path = *((string **)dub_checksdata(L, 2, "string"));
      bool bRelativeToData = dub_checkboolean(L, 3);
      lua_pushboolean(L, self->copyTo(*path, bRelativeToData));
      return 1;
    } else {
      string *path = *((string **)dub_checksdata(L, 2, "string"));
      lua_pushboolean(L, self->copyTo(*path));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "copyTo: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "copyTo: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofDirectory::moveTo(string path, bool bRelativeToData=true, bool overwrite=false)
 * api/openFrameworks/utils/ofFileUtils.h:223
 */
static int ofDirectory_moveTo(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    int top__ = lua_gettop(L);
    if (top__ >= 4) {
      string *path = *((string **)dub_checksdata(L, 2, "string"));
      bool bRelativeToData = dub_checkboolean(L, 3);
      bool overwrite = dub_checkboolean(L, 4);
      lua_pushboolean(L, self->moveTo(*path, bRelativeToData, overwrite));
      return 1;
    } else if (top__ >= 3) {
      string *path = *((string **)dub_checksdata(L, 2, "string"));
      bool bRelativeToData = dub_checkboolean(L, 3);
      lua_pushboolean(L, self->moveTo(*path, bRelativeToData));
      return 1;
    } else {
      string *path = *((string **)dub_checksdata(L, 2, "string"));
      lua_pushboolean(L, self->moveTo(*path));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "moveTo: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "moveTo: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofDirectory::renameTo(string path, bool bRelativeToData=true, bool overwrite=false)
 * api/openFrameworks/utils/ofFileUtils.h:224
 */
static int ofDirectory_renameTo(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    int top__ = lua_gettop(L);
    if (top__ >= 4) {
      string *path = *((string **)dub_checksdata(L, 2, "string"));
      bool bRelativeToData = dub_checkboolean(L, 3);
      bool overwrite = dub_checkboolean(L, 4);
      lua_pushboolean(L, self->renameTo(*path, bRelativeToData, overwrite));
      return 1;
    } else if (top__ >= 3) {
      string *path = *((string **)dub_checksdata(L, 2, "string"));
      bool bRelativeToData = dub_checkboolean(L, 3);
      lua_pushboolean(L, self->renameTo(*path, bRelativeToData));
      return 1;
    } else {
      string *path = *((string **)dub_checksdata(L, 2, "string"));
      lua_pushboolean(L, self->renameTo(*path));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "renameTo: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "renameTo: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofDirectory::remove(bool recursive)
 * api/openFrameworks/utils/ofFileUtils.h:227
 */
static int ofDirectory_remove(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    bool recursive = dub_checkboolean(L, 2);
    lua_pushboolean(L, self->remove(recursive));
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "remove: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "remove: Unknown exception");
  }
  return dub_error(L);
}

/** void ofDirectory::allowExt(string extension)
 * api/openFrameworks/utils/ofFileUtils.h:232
 */
static int ofDirectory_allowExt(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    string *extension = *((string **)dub_checksdata(L, 2, "string"));
    self->allowExt(*extension);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "allowExt: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "allowExt: Unknown exception");
  }
  return dub_error(L);
}

/** int ofDirectory::listDir(string path)
 * api/openFrameworks/utils/ofFileUtils.h:233
 */
static int ofDirectory_listDir(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    int top__ = lua_gettop(L);
    if (top__ >= 2) {
      string *path = *((string **)dub_checksdata(L, 2, "string"));
      lua_pushnumber(L, self->listDir(*path));
      return 1;
    } else {
      lua_pushnumber(L, self->listDir());
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "listDir: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "listDir: Unknown exception");
  }
  return dub_error(L);
}

/** string ofDirectory::getOriginalDirectory()
 * api/openFrameworks/utils/ofFileUtils.h:236
 */
static int ofDirectory_getOriginalDirectory(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    dub_pushudata(L, new string(self->getOriginalDirectory()), "string", true);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getOriginalDirectory: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getOriginalDirectory: Unknown exception");
  }
  return dub_error(L);
}

/** string ofDirectory::getName(unsigned int position)
 * api/openFrameworks/utils/ofFileUtils.h:237
 */
static int ofDirectory_getName(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    unsigned int position = dub_checkint(L, 2);
    dub_pushudata(L, new string(self->getName(position)), "string", true);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getName: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getName: Unknown exception");
  }
  return dub_error(L);
}

/** string ofDirectory::getPath(unsigned int position)
 * api/openFrameworks/utils/ofFileUtils.h:238
 */
static int ofDirectory_getPath(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    unsigned int position = dub_checkint(L, 2);
    dub_pushudata(L, new string(self->getPath(position)), "string", true);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getPath: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getPath: Unknown exception");
  }
  return dub_error(L);
}

/** ofFile ofDirectory::getFile(unsigned int position, ofFile::Mode mode=ofFile::Reference, bool binary=false)
 * api/openFrameworks/utils/ofFileUtils.h:239
 */
static int ofDirectory_getFile(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    int top__ = lua_gettop(L);
    if (top__ >= 4) {
      unsigned int position = dub_checkint(L, 2);
      ofFile::Mode mode = (ofFile::Mode)dub_checkint(L, 3);
      bool binary = dub_checkboolean(L, 4);
      dub_pushudata(L, new ofFile(self->getFile(position, mode, binary)), "ofFile", true);
      return 1;
    } else if (top__ >= 3) {
      unsigned int position = dub_checkint(L, 2);
      ofFile::Mode mode = (ofFile::Mode)dub_checkint(L, 3);
      dub_pushudata(L, new ofFile(self->getFile(position, mode)), "ofFile", true);
      return 1;
    } else {
      unsigned int position = dub_checkint(L, 2);
      dub_pushudata(L, new ofFile(self->getFile(position)), "ofFile", true);
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "getFile: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getFile: Unknown exception");
  }
  return dub_error(L);
}

/** vector<ofFile> ofDirectory::getFiles()
 * api/openFrameworks/utils/ofFileUtils.h:240
 */
static int ofDirectory_getFiles(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    dub_pushudata(L, new vector< ofFile >(self->getFiles()), "vector< ofFile >", true);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getFiles: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getFiles: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofDirectory::getShowHidden()
 * api/openFrameworks/utils/ofFileUtils.h:244
 */
static int ofDirectory_getShowHidden(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    lua_pushboolean(L, self->getShowHidden());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getShowHidden: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getShowHidden: Unknown exception");
  }
  return dub_error(L);
}

/** void ofDirectory::reset()
 * api/openFrameworks/utils/ofFileUtils.h:246
 */
static int ofDirectory_reset(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    self->reset();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "reset: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "reset: Unknown exception");
  }
  return dub_error(L);
}

/** void ofDirectory::sort()
 * api/openFrameworks/utils/ofFileUtils.h:247
 */
static int ofDirectory_sort(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    self->sort();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "sort: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "sort: Unknown exception");
  }
  return dub_error(L);
}

/** unsigned int ofDirectory::size()
 * api/openFrameworks/utils/ofFileUtils.h:249
 */
static int ofDirectory_size(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    lua_pushnumber(L, self->size());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "size: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "size: Unknown exception");
  }
  return dub_error(L);
}

/** int ofDirectory::numFiles()
 * api/openFrameworks/utils/ofFileUtils.h:250
 */
static int ofDirectory_numFiles(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    lua_pushnumber(L, self->numFiles());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "numFiles: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "numFiles: Unknown exception");
  }
  return dub_error(L);
}

/** Poco::File& ofDirectory::getPocoFile()
 * api/openFrameworks/utils/ofFileUtils.h:255
 */
static int ofDirectory_getPocoFile(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    dub_pushudata(L, &self->getPocoFile(), "Poco::File", false);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getPocoFile: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getPocoFile: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofDirectory::operator==(const ofDirectory &dir)
 * api/openFrameworks/utils/ofFileUtils.h:258
 */
static int ofDirectory_operator_eq(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    ofDirectory *dir = *((ofDirectory **)dub_checksdata(L, 2, "ofDirectory"));
    lua_pushboolean(L, self->operator==(*dir));
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "__eq: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "__eq: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofDirectory::operator<(const ofDirectory &dir)
 * api/openFrameworks/utils/ofFileUtils.h:260
 */
static int ofDirectory_operator_lt(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    ofDirectory *dir = *((ofDirectory **)dub_checksdata(L, 2, "ofDirectory"));
    lua_pushboolean(L, self->operator<(*dir));
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "__lt: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "__lt: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofDirectory::operator<=(const ofDirectory &dir)
 * api/openFrameworks/utils/ofFileUtils.h:261
 */
static int ofDirectory_operator_le(lua_State *L) {
  try {
    ofDirectory *self = *((ofDirectory **)dub_checksdata(L, 1, "ofDirectory"));
    ofDirectory *dir = *((ofDirectory **)dub_checksdata(L, 2, "ofDirectory"));
    lua_pushboolean(L, self->operator<=(*dir));
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "__le: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "__le: Unknown exception");
  }
  return dub_error(L);
}

/** static bool ofDirectory::createDirectory(string dirPath, bool bRelativeToData=true, bool recursive=false)
 * api/openFrameworks/utils/ofFileUtils.h:270
 */
static int ofDirectory_createDirectory(lua_State *L) {
  try {
    int top__ = lua_gettop(L);
    if (top__ >= 3) {
      string *dirPath = *((string **)dub_checksdata(L, 1, "string"));
      bool bRelativeToData = dub_checkboolean(L, 2);
      bool recursive = dub_checkboolean(L, 3);
      lua_pushboolean(L, ofDirectory::createDirectory(*dirPath, bRelativeToData, recursive));
      return 1;
    } else if (top__ >= 2) {
      string *dirPath = *((string **)dub_checksdata(L, 1, "string"));
      bool bRelativeToData = dub_checkboolean(L, 2);
      lua_pushboolean(L, ofDirectory::createDirectory(*dirPath, bRelativeToData));
      return 1;
    } else {
      string *dirPath = *((string **)dub_checksdata(L, 1, "string"));
      lua_pushboolean(L, ofDirectory::createDirectory(*dirPath));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "createDirectory: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "createDirectory: Unknown exception");
  }
  return dub_error(L);
}

/** static bool ofDirectory::isDirectoryEmpty(string dirPath, bool bRelativeToData=true)
 * api/openFrameworks/utils/ofFileUtils.h:271
 */
static int ofDirectory_isDirectoryEmpty(lua_State *L) {
  try {
    int top__ = lua_gettop(L);
    if (top__ >= 2) {
      string *dirPath = *((string **)dub_checksdata(L, 1, "string"));
      bool bRelativeToData = dub_checkboolean(L, 2);
      lua_pushboolean(L, ofDirectory::isDirectoryEmpty(*dirPath, bRelativeToData));
      return 1;
    } else {
      string *dirPath = *((string **)dub_checksdata(L, 1, "string"));
      lua_pushboolean(L, ofDirectory::isDirectoryEmpty(*dirPath));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "isDirectoryEmpty: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "isDirectoryEmpty: Unknown exception");
  }
  return dub_error(L);
}

/** static bool ofDirectory::doesDirectoryExist(string dirPath, bool bRelativeToData=true)
 * api/openFrameworks/utils/ofFileUtils.h:272
 */
static int ofDirectory_doesDirectoryExist(lua_State *L) {
  try {
    int top__ = lua_gettop(L);
    if (top__ >= 2) {
      string *dirPath = *((string **)dub_checksdata(L, 1, "string"));
      bool bRelativeToData = dub_checkboolean(L, 2);
      lua_pushboolean(L, ofDirectory::doesDirectoryExist(*dirPath, bRelativeToData));
      return 1;
    } else {
      string *dirPath = *((string **)dub_checksdata(L, 1, "string"));
      lua_pushboolean(L, ofDirectory::doesDirectoryExist(*dirPath));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "doesDirectoryExist: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "doesDirectoryExist: Unknown exception");
  }
  return dub_error(L);
}

/** static bool ofDirectory::removeDirectory(string path, bool deleteIfNotEmpty, bool bRelativeToData=true)
 * api/openFrameworks/utils/ofFileUtils.h:273
 */
static int ofDirectory_removeDirectory(lua_State *L) {
  try {
    int top__ = lua_gettop(L);
    if (top__ >= 3) {
      string *path = *((string **)dub_checksdata(L, 1, "string"));
      bool deleteIfNotEmpty = dub_checkboolean(L, 2);
      bool bRelativeToData = dub_checkboolean(L, 3);
      lua_pushboolean(L, ofDirectory::removeDirectory(*path, deleteIfNotEmpty, bRelativeToData));
      return 1;
    } else {
      string *path = *((string **)dub_checksdata(L, 1, "string"));
      bool deleteIfNotEmpty = dub_checkboolean(L, 2);
      lua_pushboolean(L, ofDirectory::removeDirectory(*path, deleteIfNotEmpty));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "removeDirectory: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "removeDirectory: Unknown exception");
  }
  return dub_error(L);
}



// --=============================================== __tostring
static int ofDirectory___tostring(lua_State *L) {
  ofDirectory *self = *((ofDirectory **)dub_checksdata_n(L, 1, "ofDirectory"));
  lua_pushfstring(L, "ofDirectory: %p", self);
  
  return 1;
}

// --=============================================== METHODS

static const struct luaL_Reg ofDirectory_member_methods[] = {
  { "__gc"         , ofDirectory__ofDirectory },
  { "new"          , ofDirectory_ofDirectory },
  { "open"         , ofDirectory_open     },
  { "close"        , ofDirectory_close    },
  { "create"       , ofDirectory_create   },
  { "exists"       , ofDirectory_exists   },
  { "path"         , ofDirectory_path     },
  { "getAbsolutePath", ofDirectory_getAbsolutePath },
  { "isDirectory"  , ofDirectory_isDirectory },
  { "isHidden"     , ofDirectory_isHidden },
  { "setWriteable" , ofDirectory_setWriteable },
  { "setReadOnly"  , ofDirectory_setReadOnly },
  { "setExecutable", ofDirectory_setExecutable },
  { "setShowHidden", ofDirectory_setShowHidden },
  { "copyTo"       , ofDirectory_copyTo   },
  { "moveTo"       , ofDirectory_moveTo   },
  { "renameTo"     , ofDirectory_renameTo },
  { "remove"       , ofDirectory_remove   },
  { "allowExt"     , ofDirectory_allowExt },
  { "listDir"      , ofDirectory_listDir  },
  { "getOriginalDirectory", ofDirectory_getOriginalDirectory },
  { "getName"      , ofDirectory_getName  },
  { "getPath"      , ofDirectory_getPath  },
  { "getFile"      , ofDirectory_getFile  },
  { "getFiles"     , ofDirectory_getFiles },
  { "getShowHidden", ofDirectory_getShowHidden },
  { "reset"        , ofDirectory_reset    },
  { "sort"         , ofDirectory_sort     },
  { "size"         , ofDirectory_size     },
  { "numFiles"     , ofDirectory_numFiles },
  { "getPocoFile"  , ofDirectory_getPocoFile },
  { "__eq"         , ofDirectory_operator_eq },
  { "__lt"         , ofDirectory_operator_lt },
  { "__le"         , ofDirectory_operator_le },
  { "createDirectory", ofDirectory_createDirectory },
  { "isDirectoryEmpty", ofDirectory_isDirectoryEmpty },
  { "doesDirectoryExist", ofDirectory_doesDirectoryExist },
  { "removeDirectory", ofDirectory_removeDirectory },
  { "__tostring"   , ofDirectory___tostring },
  { "deleted"      , dub_isDeleted        },
  { NULL, NULL},
};


extern "C" int luaopen_ofDirectory(lua_State *L)
{
  // Create the metatable which will contain all the member methods
  luaL_newmetatable(L, "ofDirectory");
  // <mt>

  // register member methods
  luaL_register(L, NULL, ofDirectory_member_methods);
  // save meta-table in _G
  dub_register(L, "_G", "ofDirectory", "ofDirectory");
  // <mt>
  lua_pop(L, 1);
  return 0;
}
