/**
 *
 * MACHINE GENERATED FILE. DO NOT EDIT.
 *
 * Bindings for class ofFile
 *
 * This file has been generated by dub 2.1.~.
 */
#include "dub/dub.h"
#include "utils/ofFileUtils.h"


/** ofFile::ofFile()
 * api/openFrameworks/utils/ofFileUtils.h:100
 */
static int ofFile_ofFile(lua_State *L) {
  try {
    int top__ = lua_gettop(L);
    if (top__ >= 3) {
      size_t filePath_sz_;
      const char *filePath = dub_checklstring(L, 1, &filePath_sz_);
      ofFile::Mode mode = (ofFile::Mode)dub_checkint(L, 2);
      bool binary = dub_checkboolean(L, 3);
      ofFile *retval__ = new ofFile(std::string(filePath, filePath_sz_), mode, binary);
      dub_pushudata(L, retval__, "ofFile", true);
      return 1;
    } else if (top__ >= 2) {
      size_t filePath_sz_;
      const char *filePath = dub_checklstring(L, 1, &filePath_sz_);
      ofFile::Mode mode = (ofFile::Mode)dub_checkint(L, 2);
      ofFile *retval__ = new ofFile(std::string(filePath, filePath_sz_), mode);
      dub_pushudata(L, retval__, "ofFile", true);
      return 1;
    } else if (top__ >= 1) {
      int type__ = lua_type(L, 1);
      void **ptr1__;
      if ( (ptr1__ = dub_issdata(L, 1, "ofFile", type__)) ) {
        ofFile *mom = *((ofFile **)ptr1__);
        ofFile *retval__ = new ofFile(*mom);
        dub_pushudata(L, retval__, "ofFile", true);
        return 1;
      } else {
        size_t filePath_sz_;
        const char *filePath = dub_checklstring(L, 1, &filePath_sz_);
        ofFile *retval__ = new ofFile(std::string(filePath, filePath_sz_));
        dub_pushudata(L, retval__, "ofFile", true);
        return 1;
      }
    } else {
      ofFile *retval__ = new ofFile();
      dub_pushudata(L, retval__, "ofFile", true);
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "new: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "new: Unknown exception");
  }
  return dub_error(L);
}

/** ofFile& ofFile::operator=(const ofFile &mom)
 * api/openFrameworks/utils/ofFileUtils.h:103
 */
static int ofFile_operator_sete(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    ofFile *mom = *((ofFile **)dub_checksdata(L, 2, "ofFile"));
    dub_pushudata(L, &self->operator=(*mom), "ofFile", false);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "set: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "set: Unknown exception");
  }
  return dub_error(L);
}

/** ofFile::~ofFile()
 * api/openFrameworks/utils/ofFileUtils.h:104
 */
static int ofFile__ofFile(lua_State *L) {
  try {
    DubUserdata *userdata = ((DubUserdata*)dub_checksdata_d(L, 1, "ofFile"));
    if (userdata->gc) {
      ofFile *self = (ofFile *)userdata->ptr;
      delete self;
    }
    userdata->gc = false;
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "__gc: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "__gc: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::open(string path, Mode mode=ReadOnly, bool binary=false)
 * api/openFrameworks/utils/ofFileUtils.h:106
 */
static int ofFile_open(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    int top__ = lua_gettop(L);
    if (top__ >= 4) {
      size_t path_sz_;
      const char *path = dub_checklstring(L, 2, &path_sz_);
      ofFile::Mode mode = (ofFile::Mode)dub_checkint(L, 3);
      bool binary = dub_checkboolean(L, 4);
      lua_pushboolean(L, self->open(std::string(path, path_sz_), mode, binary));
      return 1;
    } else if (top__ >= 3) {
      size_t path_sz_;
      const char *path = dub_checklstring(L, 2, &path_sz_);
      ofFile::Mode mode = (ofFile::Mode)dub_checkint(L, 3);
      lua_pushboolean(L, self->open(std::string(path, path_sz_), mode));
      return 1;
    } else {
      size_t path_sz_;
      const char *path = dub_checklstring(L, 2, &path_sz_);
      lua_pushboolean(L, self->open(std::string(path, path_sz_)));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "open: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "open: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::changeMode(Mode mode, bool binary=false)
 * api/openFrameworks/utils/ofFileUtils.h:107
 */
static int ofFile_changeMode(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    int top__ = lua_gettop(L);
    if (top__ >= 3) {
      ofFile::Mode mode = (ofFile::Mode)dub_checkint(L, 2);
      bool binary = dub_checkboolean(L, 3);
      lua_pushboolean(L, self->changeMode(mode, binary));
      return 1;
    } else {
      ofFile::Mode mode = (ofFile::Mode)dub_checkint(L, 2);
      lua_pushboolean(L, self->changeMode(mode));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "changeMode: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "changeMode: Unknown exception");
  }
  return dub_error(L);
}

/** void ofFile::close()
 * api/openFrameworks/utils/ofFileUtils.h:108
 */
static int ofFile_close(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    self->close();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "close: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "close: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::create()
 * api/openFrameworks/utils/ofFileUtils.h:109
 */
static int ofFile_create(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushboolean(L, self->create());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "create: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "create: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::exists() const
 * api/openFrameworks/utils/ofFileUtils.h:111
 */
static int ofFile_exists(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushboolean(L, self->exists());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "exists: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "exists: Unknown exception");
  }
  return dub_error(L);
}

/** string ofFile::path() const
 * api/openFrameworks/utils/ofFileUtils.h:112
 */
static int ofFile_path(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushlstring(L, self->path().data(), self->path().length());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "path: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "path: Unknown exception");
  }
  return dub_error(L);
}

/** string ofFile::getExtension() const
 * api/openFrameworks/utils/ofFileUtils.h:114
 */
static int ofFile_getExtension(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushlstring(L, self->getExtension().data(), self->getExtension().length());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getExtension: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getExtension: Unknown exception");
  }
  return dub_error(L);
}

/** string ofFile::getFileName() const
 * api/openFrameworks/utils/ofFileUtils.h:115
 */
static int ofFile_getFileName(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushlstring(L, self->getFileName().data(), self->getFileName().length());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getFileName: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getFileName: Unknown exception");
  }
  return dub_error(L);
}

/** string ofFile::getBaseName() const
 * api/openFrameworks/utils/ofFileUtils.h:116
 */
static int ofFile_getBaseName(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushlstring(L, self->getBaseName().data(), self->getBaseName().length());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getBaseName: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getBaseName: Unknown exception");
  }
  return dub_error(L);
}

/** string ofFile::getEnclosingDirectory() const
 * api/openFrameworks/utils/ofFileUtils.h:117
 */
static int ofFile_getEnclosingDirectory(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushlstring(L, self->getEnclosingDirectory().data(), self->getEnclosingDirectory().length());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getEnclosingDirectory: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getEnclosingDirectory: Unknown exception");
  }
  return dub_error(L);
}

/** string ofFile::getAbsolutePath() const
 * api/openFrameworks/utils/ofFileUtils.h:118
 */
static int ofFile_getAbsolutePath(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushlstring(L, self->getAbsolutePath().data(), self->getAbsolutePath().length());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getAbsolutePath: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getAbsolutePath: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::canRead() const
 * api/openFrameworks/utils/ofFileUtils.h:120
 */
static int ofFile_canRead(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushboolean(L, self->canRead());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "canRead: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "canRead: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::canWrite() const
 * api/openFrameworks/utils/ofFileUtils.h:121
 */
static int ofFile_canWrite(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushboolean(L, self->canWrite());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "canWrite: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "canWrite: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::canExecute() const
 * api/openFrameworks/utils/ofFileUtils.h:122
 */
static int ofFile_canExecute(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushboolean(L, self->canExecute());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "canExecute: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "canExecute: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::isFile() const
 * api/openFrameworks/utils/ofFileUtils.h:124
 */
static int ofFile_isFile(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushboolean(L, self->isFile());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "isFile: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "isFile: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::isLink() const
 * api/openFrameworks/utils/ofFileUtils.h:125
 */
static int ofFile_isLink(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushboolean(L, self->isLink());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "isLink: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "isLink: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::isDirectory() const
 * api/openFrameworks/utils/ofFileUtils.h:126
 */
static int ofFile_isDirectory(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushboolean(L, self->isDirectory());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "isDirectory: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "isDirectory: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::isDevice() const
 * api/openFrameworks/utils/ofFileUtils.h:127
 */
static int ofFile_isDevice(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushboolean(L, self->isDevice());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "isDevice: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "isDevice: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::isHidden() const
 * api/openFrameworks/utils/ofFileUtils.h:128
 */
static int ofFile_isHidden(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    lua_pushboolean(L, self->isHidden());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "isHidden: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "isHidden: Unknown exception");
  }
  return dub_error(L);
}

/** void ofFile::setWriteable(bool writeable)
 * api/openFrameworks/utils/ofFileUtils.h:130
 */
static int ofFile_setWriteable(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    bool writeable = dub_checkboolean(L, 2);
    self->setWriteable(writeable);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "setWriteable: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "setWriteable: Unknown exception");
  }
  return dub_error(L);
}

/** void ofFile::setReadOnly(bool readable)
 * api/openFrameworks/utils/ofFileUtils.h:131
 */
static int ofFile_setReadOnly(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    bool readable = dub_checkboolean(L, 2);
    self->setReadOnly(readable);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "setReadOnly: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "setReadOnly: Unknown exception");
  }
  return dub_error(L);
}

/** void ofFile::setExecutable(bool executable)
 * api/openFrameworks/utils/ofFileUtils.h:132
 */
static int ofFile_setExecutable(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    bool executable = dub_checkboolean(L, 2);
    self->setExecutable(executable);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "setExecutable: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "setExecutable: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::copyTo(string path, bool bRelativeToData=true, bool overwrite=false)
 * api/openFrameworks/utils/ofFileUtils.h:135
 */
static int ofFile_copyTo(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    int top__ = lua_gettop(L);
    if (top__ >= 4) {
      size_t path_sz_;
      const char *path = dub_checklstring(L, 2, &path_sz_);
      bool bRelativeToData = dub_checkboolean(L, 3);
      bool overwrite = dub_checkboolean(L, 4);
      lua_pushboolean(L, self->copyTo(std::string(path, path_sz_), bRelativeToData, overwrite));
      return 1;
    } else if (top__ >= 3) {
      size_t path_sz_;
      const char *path = dub_checklstring(L, 2, &path_sz_);
      bool bRelativeToData = dub_checkboolean(L, 3);
      lua_pushboolean(L, self->copyTo(std::string(path, path_sz_), bRelativeToData));
      return 1;
    } else {
      size_t path_sz_;
      const char *path = dub_checklstring(L, 2, &path_sz_);
      lua_pushboolean(L, self->copyTo(std::string(path, path_sz_)));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "copyTo: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "copyTo: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::moveTo(string path, bool bRelativeToData=true, bool overwrite=false)
 * api/openFrameworks/utils/ofFileUtils.h:136
 */
static int ofFile_moveTo(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    int top__ = lua_gettop(L);
    if (top__ >= 4) {
      size_t path_sz_;
      const char *path = dub_checklstring(L, 2, &path_sz_);
      bool bRelativeToData = dub_checkboolean(L, 3);
      bool overwrite = dub_checkboolean(L, 4);
      lua_pushboolean(L, self->moveTo(std::string(path, path_sz_), bRelativeToData, overwrite));
      return 1;
    } else if (top__ >= 3) {
      size_t path_sz_;
      const char *path = dub_checklstring(L, 2, &path_sz_);
      bool bRelativeToData = dub_checkboolean(L, 3);
      lua_pushboolean(L, self->moveTo(std::string(path, path_sz_), bRelativeToData));
      return 1;
    } else {
      size_t path_sz_;
      const char *path = dub_checklstring(L, 2, &path_sz_);
      lua_pushboolean(L, self->moveTo(std::string(path, path_sz_)));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "moveTo: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "moveTo: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::renameTo(string path, bool bRelativeToData=true, bool overwrite=false)
 * api/openFrameworks/utils/ofFileUtils.h:137
 */
static int ofFile_renameTo(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    int top__ = lua_gettop(L);
    if (top__ >= 4) {
      size_t path_sz_;
      const char *path = dub_checklstring(L, 2, &path_sz_);
      bool bRelativeToData = dub_checkboolean(L, 3);
      bool overwrite = dub_checkboolean(L, 4);
      lua_pushboolean(L, self->renameTo(std::string(path, path_sz_), bRelativeToData, overwrite));
      return 1;
    } else if (top__ >= 3) {
      size_t path_sz_;
      const char *path = dub_checklstring(L, 2, &path_sz_);
      bool bRelativeToData = dub_checkboolean(L, 3);
      lua_pushboolean(L, self->renameTo(std::string(path, path_sz_), bRelativeToData));
      return 1;
    } else {
      size_t path_sz_;
      const char *path = dub_checklstring(L, 2, &path_sz_);
      lua_pushboolean(L, self->renameTo(std::string(path, path_sz_)));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "renameTo: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "renameTo: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::remove(bool recursive=false)
 * api/openFrameworks/utils/ofFileUtils.h:141
 */
static int ofFile_remove(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    int top__ = lua_gettop(L);
    if (top__ >= 2) {
      bool recursive = dub_checkboolean(L, 2);
      lua_pushboolean(L, self->remove(recursive));
      return 1;
    } else {
      lua_pushboolean(L, self->remove());
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "remove: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "remove: Unknown exception");
  }
  return dub_error(L);
}

/** uint64_t ofFile::getSize() const
 * api/openFrameworks/utils/ofFileUtils.h:143
 */
static int ofFile_getSize(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    dub_pushudata(L, new uint64_t(self->getSize()), "uint64", true);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getSize: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getSize: Unknown exception");
  }
  return dub_error(L);
}

/** Poco::File& ofFile::getPocoFile()
 * api/openFrameworks/utils/ofFileUtils.h:146
 */
static int ofFile_getPocoFile(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    dub_pushudata(L, &self->getPocoFile(), "Poco::File", false);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getPocoFile: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getPocoFile: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::operator==(const ofFile &file) const
 * api/openFrameworks/utils/ofFileUtils.h:149
 */
static int ofFile_operator_eq(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    ofFile *file = *((ofFile **)dub_checksdata(L, 2, "ofFile"));
    lua_pushboolean(L, self->operator==(*file));
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "__eq: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "__eq: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::operator<(const ofFile &file) const
 * api/openFrameworks/utils/ofFileUtils.h:151
 */
static int ofFile_operator_lt(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    ofFile *file = *((ofFile **)dub_checksdata(L, 2, "ofFile"));
    lua_pushboolean(L, self->operator<(*file));
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "__lt: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "__lt: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::operator<=(const ofFile &file) const
 * api/openFrameworks/utils/ofFileUtils.h:152
 */
static int ofFile_operator_le(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    ofFile *file = *((ofFile **)dub_checksdata(L, 2, "ofFile"));
    lua_pushboolean(L, self->operator<=(*file));
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "__le: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "__le: Unknown exception");
  }
  return dub_error(L);
}

/** ofBuffer ofFile::readToBuffer()
 * api/openFrameworks/utils/ofFileUtils.h:166
 */
static int ofFile_readToBuffer(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    dub_pushudata(L, new ofBuffer(self->readToBuffer()), "ofBuffer", true);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "readToBuffer: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "readToBuffer: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofFile::writeFromBuffer(ofBuffer &buffer)
 * api/openFrameworks/utils/ofFileUtils.h:167
 */
static int ofFile_writeFromBuffer(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    ofBuffer *buffer = *((ofBuffer **)dub_checksdata(L, 2, "ofBuffer"));
    lua_pushboolean(L, self->writeFromBuffer(*buffer));
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "writeFromBuffer: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "writeFromBuffer: Unknown exception");
  }
  return dub_error(L);
}

/** filebuf* ofFile::getFileBuffer() const
 * api/openFrameworks/utils/ofFileUtils.h:174
 */
static int ofFile_getFileBuffer(lua_State *L) {
  try {
    ofFile *self = *((ofFile **)dub_checksdata(L, 1, "ofFile"));
    filebuf *retval__ = self->getFileBuffer();
    if (!retval__) return 0;
    dub_pushudata(L, retval__, "filebuf", false);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getFileBuffer: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getFileBuffer: Unknown exception");
  }
  return dub_error(L);
}

/** static bool ofFile::copyFromTo(string pathSrc, string pathDst, bool bRelativeToData=true, bool overwrite=false)
 * api/openFrameworks/utils/ofFileUtils.h:181
 */
static int ofFile_copyFromTo(lua_State *L) {
  try {
    int top__ = lua_gettop(L);
    if (top__ >= 4) {
      size_t pathSrc_sz_;
      const char *pathSrc = dub_checklstring(L, 1, &pathSrc_sz_);
      size_t pathDst_sz_;
      const char *pathDst = dub_checklstring(L, 2, &pathDst_sz_);
      bool bRelativeToData = dub_checkboolean(L, 3);
      bool overwrite = dub_checkboolean(L, 4);
      lua_pushboolean(L, ofFile::copyFromTo(std::string(pathSrc, pathSrc_sz_), std::string(pathDst, pathDst_sz_), bRelativeToData, overwrite));
      return 1;
    } else if (top__ >= 3) {
      size_t pathSrc_sz_;
      const char *pathSrc = dub_checklstring(L, 1, &pathSrc_sz_);
      size_t pathDst_sz_;
      const char *pathDst = dub_checklstring(L, 2, &pathDst_sz_);
      bool bRelativeToData = dub_checkboolean(L, 3);
      lua_pushboolean(L, ofFile::copyFromTo(std::string(pathSrc, pathSrc_sz_), std::string(pathDst, pathDst_sz_), bRelativeToData));
      return 1;
    } else {
      size_t pathSrc_sz_;
      const char *pathSrc = dub_checklstring(L, 1, &pathSrc_sz_);
      size_t pathDst_sz_;
      const char *pathDst = dub_checklstring(L, 2, &pathDst_sz_);
      lua_pushboolean(L, ofFile::copyFromTo(std::string(pathSrc, pathSrc_sz_), std::string(pathDst, pathDst_sz_)));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "copyFromTo: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "copyFromTo: Unknown exception");
  }
  return dub_error(L);
}

/** static bool ofFile::moveFromTo(string pathSrc, string pathDst, bool bRelativeToData=true, bool overwrite=false)
 * api/openFrameworks/utils/ofFileUtils.h:184
 */
static int ofFile_moveFromTo(lua_State *L) {
  try {
    int top__ = lua_gettop(L);
    if (top__ >= 4) {
      size_t pathSrc_sz_;
      const char *pathSrc = dub_checklstring(L, 1, &pathSrc_sz_);
      size_t pathDst_sz_;
      const char *pathDst = dub_checklstring(L, 2, &pathDst_sz_);
      bool bRelativeToData = dub_checkboolean(L, 3);
      bool overwrite = dub_checkboolean(L, 4);
      lua_pushboolean(L, ofFile::moveFromTo(std::string(pathSrc, pathSrc_sz_), std::string(pathDst, pathDst_sz_), bRelativeToData, overwrite));
      return 1;
    } else if (top__ >= 3) {
      size_t pathSrc_sz_;
      const char *pathSrc = dub_checklstring(L, 1, &pathSrc_sz_);
      size_t pathDst_sz_;
      const char *pathDst = dub_checklstring(L, 2, &pathDst_sz_);
      bool bRelativeToData = dub_checkboolean(L, 3);
      lua_pushboolean(L, ofFile::moveFromTo(std::string(pathSrc, pathSrc_sz_), std::string(pathDst, pathDst_sz_), bRelativeToData));
      return 1;
    } else {
      size_t pathSrc_sz_;
      const char *pathSrc = dub_checklstring(L, 1, &pathSrc_sz_);
      size_t pathDst_sz_;
      const char *pathDst = dub_checklstring(L, 2, &pathDst_sz_);
      lua_pushboolean(L, ofFile::moveFromTo(std::string(pathSrc, pathSrc_sz_), std::string(pathDst, pathDst_sz_)));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "moveFromTo: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "moveFromTo: Unknown exception");
  }
  return dub_error(L);
}

/** static bool ofFile::doesFileExist(string fPath, bool bRelativeToData=true)
 * api/openFrameworks/utils/ofFileUtils.h:185
 */
static int ofFile_doesFileExist(lua_State *L) {
  try {
    int top__ = lua_gettop(L);
    if (top__ >= 2) {
      size_t fPath_sz_;
      const char *fPath = dub_checklstring(L, 1, &fPath_sz_);
      bool bRelativeToData = dub_checkboolean(L, 2);
      lua_pushboolean(L, ofFile::doesFileExist(std::string(fPath, fPath_sz_), bRelativeToData));
      return 1;
    } else {
      size_t fPath_sz_;
      const char *fPath = dub_checklstring(L, 1, &fPath_sz_);
      lua_pushboolean(L, ofFile::doesFileExist(std::string(fPath, fPath_sz_)));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "doesFileExist: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "doesFileExist: Unknown exception");
  }
  return dub_error(L);
}

/** static bool ofFile::removeFile(string path, bool bRelativeToData=true)
 * api/openFrameworks/utils/ofFileUtils.h:186
 */
static int ofFile_removeFile(lua_State *L) {
  try {
    int top__ = lua_gettop(L);
    if (top__ >= 2) {
      size_t path_sz_;
      const char *path = dub_checklstring(L, 1, &path_sz_);
      bool bRelativeToData = dub_checkboolean(L, 2);
      lua_pushboolean(L, ofFile::removeFile(std::string(path, path_sz_), bRelativeToData));
      return 1;
    } else {
      size_t path_sz_;
      const char *path = dub_checklstring(L, 1, &path_sz_);
      lua_pushboolean(L, ofFile::removeFile(std::string(path, path_sz_)));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "removeFile: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "removeFile: Unknown exception");
  }
  return dub_error(L);
}



// --=============================================== __tostring
static int ofFile___tostring(lua_State *L) {
  ofFile *self = *((ofFile **)dub_checksdata_n(L, 1, "ofFile"));
  lua_pushfstring(L, "ofFile: %p", self);
  
  return 1;
}

// --=============================================== METHODS

static const struct luaL_Reg ofFile_member_methods[] = {
  { "new"          , ofFile_ofFile        },
  { "set"          , ofFile_operator_sete },
  { "__gc"         , ofFile__ofFile       },
  { "open"         , ofFile_open          },
  { "changeMode"   , ofFile_changeMode    },
  { "close"        , ofFile_close         },
  { "create"       , ofFile_create        },
  { "exists"       , ofFile_exists        },
  { "path"         , ofFile_path          },
  { "getExtension" , ofFile_getExtension  },
  { "getFileName"  , ofFile_getFileName   },
  { "getBaseName"  , ofFile_getBaseName   },
  { "getEnclosingDirectory", ofFile_getEnclosingDirectory },
  { "getAbsolutePath", ofFile_getAbsolutePath },
  { "canRead"      , ofFile_canRead       },
  { "canWrite"     , ofFile_canWrite      },
  { "canExecute"   , ofFile_canExecute    },
  { "isFile"       , ofFile_isFile        },
  { "isLink"       , ofFile_isLink        },
  { "isDirectory"  , ofFile_isDirectory   },
  { "isDevice"     , ofFile_isDevice      },
  { "isHidden"     , ofFile_isHidden      },
  { "setWriteable" , ofFile_setWriteable  },
  { "setReadOnly"  , ofFile_setReadOnly   },
  { "setExecutable", ofFile_setExecutable },
  { "copyTo"       , ofFile_copyTo        },
  { "moveTo"       , ofFile_moveTo        },
  { "renameTo"     , ofFile_renameTo      },
  { "remove"       , ofFile_remove        },
  { "getSize"      , ofFile_getSize       },
  { "getPocoFile"  , ofFile_getPocoFile   },
  { "__eq"         , ofFile_operator_eq   },
  { "__lt"         , ofFile_operator_lt   },
  { "__le"         , ofFile_operator_le   },
  { "readToBuffer" , ofFile_readToBuffer  },
  { "writeFromBuffer", ofFile_writeFromBuffer },
  { "getFileBuffer", ofFile_getFileBuffer },
  { "copyFromTo"   , ofFile_copyFromTo    },
  { "moveFromTo"   , ofFile_moveFromTo    },
  { "doesFileExist", ofFile_doesFileExist },
  { "removeFile"   , ofFile_removeFile    },
  { "__tostring"   , ofFile___tostring    },
  { "deleted"      , dub_isDeleted        },
  { NULL, NULL},
};

// --=============================================== CONSTANTS
static const struct dub_const_Reg ofFile_const[] = {
  { "Reference"    , ofFile::Reference    },
  { "ReadOnly"     , ofFile::ReadOnly     },
  { "WriteOnly"    , ofFile::WriteOnly    },
  { "ReadWrite"    , ofFile::ReadWrite    },
  { "Append"       , ofFile::Append       },
  { NULL, 0},
};

extern "C" int luaopen_ofFile(lua_State *L)
{
  // Create the metatable which will contain all the member methods
  luaL_newmetatable(L, "ofFile");
  // <mt>
  // register class constants
  dub_register_const(L, ofFile_const);

  // register member methods
  luaL_register(L, NULL, ofFile_member_methods);
  // save meta-table in _G
  dub_register(L, "_G", "ofFile", "ofFile");
  // <mt>
  lua_pop(L, 1);
  return 0;
}
