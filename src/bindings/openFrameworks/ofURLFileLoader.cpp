/**
 *
 * MACHINE GENERATED FILE. DO NOT EDIT.
 *
 * Bindings for class ofURLFileLoader
 *
 * This file has been generated by dub 2.1.~.
 */
#include "dub/dub.h"
#include "utils/ofURLFileLoader.h"


/** ~ofURLFileLoader()
 * 
 */
static int ofURLFileLoader__ofURLFileLoader(lua_State *L) {
  try {
    DubUserdata *userdata = ((DubUserdata*)dub_checksdata_d(L, 1, "ofURLFileLoader"));
    if (userdata->gc) {
      ofURLFileLoader *self = (ofURLFileLoader *)userdata->ptr;
      delete self;
    }
    userdata->gc = false;
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "__gc: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "__gc: Unknown exception");
  }
  return dub_error(L);
}

/** Cast (class_name)
 * 
 */
static int ofURLFileLoader__cast_(lua_State *L) {

  ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata_n(L, 1, "ofURLFileLoader"));
  const char *key = luaL_checkstring(L, 2);
  void **retval__ = (void**)lua_newuserdata(L, sizeof(void*));
  int key_h = dub_hash(key, 2);
  switch(key_h) {
    case 1: {
      if (DUB_ASSERT_KEY(key, "ofThread")) break;
      *retval__ = static_cast<ofThread *>(self);
      return 1;
    }
  }
  return 0;
}

/** ofURLFileLoader::ofURLFileLoader()
 * api/openFrameworks/utils/ofURLFileLoader.h:82
 */
static int ofURLFileLoader_ofURLFileLoader(lua_State *L) {
  try {
    ofURLFileLoader *retval__ = new ofURLFileLoader();
    dub_pushudata(L, retval__, "ofURLFileLoader", true);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "new: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "new: Unknown exception");
  }
  return dub_error(L);
}

/** ofHttpResponse ofURLFileLoader::get(string url)
 * api/openFrameworks/utils/ofURLFileLoader.h:83
 */
static int ofURLFileLoader_get(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    size_t url_sz_;
    const char *url = dub_checklstring(L, 2, &url_sz_);
    dub_pushudata(L, new ofHttpResponse(self->get(std::string(url, url_sz_))), "ofHttpResponse", true);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "get: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "get: Unknown exception");
  }
  return dub_error(L);
}

/** int ofURLFileLoader::getAsync(string url, string name="")
 * api/openFrameworks/utils/ofURLFileLoader.h:84
 */
static int ofURLFileLoader_getAsync(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    int top__ = lua_gettop(L);
    if (top__ >= 3) {
      size_t url_sz_;
      const char *url = dub_checklstring(L, 2, &url_sz_);
      size_t name_sz_;
      const char *name = dub_checklstring(L, 3, &name_sz_);
      lua_pushnumber(L, self->getAsync(std::string(url, url_sz_), std::string(name, name_sz_)));
      return 1;
    } else {
      size_t url_sz_;
      const char *url = dub_checklstring(L, 2, &url_sz_);
      lua_pushnumber(L, self->getAsync(std::string(url, url_sz_)));
      return 1;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "getAsync: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getAsync: Unknown exception");
  }
  return dub_error(L);
}

/** ofHttpResponse ofURLFileLoader::saveTo(string url, string path)
 * api/openFrameworks/utils/ofURLFileLoader.h:85
 */
static int ofURLFileLoader_saveTo(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    size_t url_sz_;
    const char *url = dub_checklstring(L, 2, &url_sz_);
    size_t path_sz_;
    const char *path = dub_checklstring(L, 3, &path_sz_);
    dub_pushudata(L, new ofHttpResponse(self->saveTo(std::string(url, url_sz_), std::string(path, path_sz_))), "ofHttpResponse", true);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "saveTo: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "saveTo: Unknown exception");
  }
  return dub_error(L);
}

/** int ofURLFileLoader::saveAsync(string url, string path)
 * api/openFrameworks/utils/ofURLFileLoader.h:86
 */
static int ofURLFileLoader_saveAsync(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    size_t url_sz_;
    const char *url = dub_checklstring(L, 2, &url_sz_);
    size_t path_sz_;
    const char *path = dub_checklstring(L, 3, &path_sz_);
    lua_pushnumber(L, self->saveAsync(std::string(url, url_sz_), std::string(path, path_sz_)));
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "saveAsync: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "saveAsync: Unknown exception");
  }
  return dub_error(L);
}

/** void ofURLFileLoader::remove(int id)
 * api/openFrameworks/utils/ofURLFileLoader.h:87
 */
static int ofURLFileLoader_remove(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    int id = dub_checkint(L, 2);
    self->remove(id);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "remove: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "remove: Unknown exception");
  }
  return dub_error(L);
}

/** void ofURLFileLoader::clear()
 * api/openFrameworks/utils/ofURLFileLoader.h:88
 */
static int ofURLFileLoader_clear(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    self->clear();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "clear: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "clear: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofThread::isThreadRunning()
 * api/openFrameworks/utils/ofThread.h:20
 */
static int ofURLFileLoader_isThreadRunning(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    lua_pushboolean(L, self->isThreadRunning());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "isThreadRunning: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "isThreadRunning: Unknown exception");
  }
  return dub_error(L);
}

/** int ofThread::getThreadId()
 * api/openFrameworks/utils/ofThread.h:25
 */
static int ofURLFileLoader_getThreadId(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    lua_pushnumber(L, self->getThreadId());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getThreadId: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getThreadId: Unknown exception");
  }
  return dub_error(L);
}

/** string ofThread::getThreadName()
 * api/openFrameworks/utils/ofThread.h:28
 */
static int ofURLFileLoader_getThreadName(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    lua_pushlstring(L, self->getThreadName().data(), self->getThreadName().length());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getThreadName: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getThreadName: Unknown exception");
  }
  return dub_error(L);
}

/** void ofThread::startThread(bool blocking=true, bool verbose=false)
 * api/openFrameworks/utils/ofThread.h:36
 */
static int ofURLFileLoader_startThread(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    int top__ = lua_gettop(L);
    if (top__ >= 3) {
      bool blocking = dub_checkboolean(L, 2);
      bool verbose = dub_checkboolean(L, 3);
      self->startThread(blocking, verbose);
      return 0;
    } else if (top__ >= 2) {
      bool blocking = dub_checkboolean(L, 2);
      self->startThread(blocking);
      return 0;
    } else {
      self->startThread();
      return 0;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "startThread: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "startThread: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofThread::lock()
 * api/openFrameworks/utils/ofThread.h:45
 */
static int ofURLFileLoader_lock(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    lua_pushboolean(L, self->lock());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "lock: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "lock: Unknown exception");
  }
  return dub_error(L);
}

/** void ofThread::unlock()
 * api/openFrameworks/utils/ofThread.h:51
 */
static int ofURLFileLoader_unlock(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    self->unlock();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "unlock: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "unlock: Unknown exception");
  }
  return dub_error(L);
}

/** void ofThread::stopThread()
 * api/openFrameworks/utils/ofThread.h:54
 */
static int ofURLFileLoader_stopThread(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    self->stopThread();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "stopThread: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "stopThread: Unknown exception");
  }
  return dub_error(L);
}

/** void ofThread::waitForThread(bool stop=true)
 * api/openFrameworks/utils/ofThread.h:67
 */
static int ofURLFileLoader_waitForThread(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    int top__ = lua_gettop(L);
    if (top__ >= 2) {
      bool stop = dub_checkboolean(L, 2);
      self->waitForThread(stop);
      return 0;
    } else {
      self->waitForThread();
      return 0;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "waitForThread: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "waitForThread: Unknown exception");
  }
  return dub_error(L);
}

/** void ofThread::sleep(int sleepMS)
 * api/openFrameworks/utils/ofThread.h:99
 */
static int ofURLFileLoader_sleep(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    int sleepMS = dub_checkint(L, 2);
    self->sleep(sleepMS);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "sleep: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "sleep: Unknown exception");
  }
  return dub_error(L);
}

/** void ofThread::yield()
 * api/openFrameworks/utils/ofThread.h:110
 */
static int ofURLFileLoader_yield(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    self->yield();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "yield: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "yield: Unknown exception");
  }
  return dub_error(L);
}

/** bool ofThread::isCurrentThread()
 * api/openFrameworks/utils/ofThread.h:128
 */
static int ofURLFileLoader_isCurrentThread(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    lua_pushboolean(L, self->isCurrentThread());
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "isCurrentThread: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "isCurrentThread: Unknown exception");
  }
  return dub_error(L);
}

/** Poco::Thread& ofThread::getPocoThread()
 * api/openFrameworks/utils/ofThread.h:131
 */
static int ofURLFileLoader_getPocoThread(lua_State *L) {
  try {
    ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata(L, 1, "ofURLFileLoader"));
    dub_pushudata(L, &self->getPocoThread(), "Poco::Thread", false);
    return 1;
  } catch (std::exception &e) {
    lua_pushfstring(L, "getPocoThread: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "getPocoThread: Unknown exception");
  }
  return dub_error(L);
}



// --=============================================== __tostring
static int ofURLFileLoader___tostring(lua_State *L) {
  ofURLFileLoader *self = *((ofURLFileLoader **)dub_checksdata_n(L, 1, "ofURLFileLoader"));
  lua_pushfstring(L, "ofURLFileLoader: %p", self);
  
  return 1;
}

// --=============================================== METHODS

static const struct luaL_Reg ofURLFileLoader_member_methods[] = {
  { "__gc"         , ofURLFileLoader__ofURLFileLoader },
  { "_cast_"       , ofURLFileLoader__cast_ },
  { "new"          , ofURLFileLoader_ofURLFileLoader },
  { "get"          , ofURLFileLoader_get  },
  { "getAsync"     , ofURLFileLoader_getAsync },
  { "saveTo"       , ofURLFileLoader_saveTo },
  { "saveAsync"    , ofURLFileLoader_saveAsync },
  { "remove"       , ofURLFileLoader_remove },
  { "clear"        , ofURLFileLoader_clear },
  { "isThreadRunning", ofURLFileLoader_isThreadRunning },
  { "getThreadId"  , ofURLFileLoader_getThreadId },
  { "getThreadName", ofURLFileLoader_getThreadName },
  { "startThread"  , ofURLFileLoader_startThread },
  { "lock"         , ofURLFileLoader_lock },
  { "unlock"       , ofURLFileLoader_unlock },
  { "stopThread"   , ofURLFileLoader_stopThread },
  { "waitForThread", ofURLFileLoader_waitForThread },
  { "sleep"        , ofURLFileLoader_sleep },
  { "yield"        , ofURLFileLoader_yield },
  { "isCurrentThread", ofURLFileLoader_isCurrentThread },
  { "getPocoThread", ofURLFileLoader_getPocoThread },
  { "__tostring"   , ofURLFileLoader___tostring },
  { "deleted"      , dub_isDeleted        },
  { NULL, NULL},
};


extern "C" int luaopen_ofURLFileLoader(lua_State *L)
{
  // Create the metatable which will contain all the member methods
  luaL_newmetatable(L, "ofURLFileLoader");
  // <mt>

  // register member methods
  luaL_register(L, NULL, ofURLFileLoader_member_methods);
  // save meta-table in _G
  dub_register(L, "_G", "ofURLFileLoader", "ofURLFileLoader");
  // <mt>
  lua_pop(L, 1);
  return 0;
}
